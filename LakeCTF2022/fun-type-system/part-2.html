<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Part 2: The second rev - Fun type system</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Lake CTF 2022</li><li class="chapter-item expanded "><a href="../../LakeCTF2022/fun-type-system/writeup.html"><strong aria-hidden="true">1.</strong> fun type system</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../LakeCTF2022/fun-type-system/part-1.html"><strong aria-hidden="true">1.1.</strong> Part 1: The first rev</a></li><li class="chapter-item expanded "><a href="../../LakeCTF2022/fun-type-system/part-2.html" class="active"><strong aria-hidden="true">1.2.</strong> Part 2: The second rev</a></li><li class="chapter-item expanded "><a href="../../LakeCTF2022/fun-type-system/part-3.html"><strong aria-hidden="true">1.3.</strong> Part 3: The solution</a></li><li class="chapter-item expanded "><a href="../../LakeCTF2022/fun-type-system/fail.html"><strong aria-hidden="true">1.4.</strong> The fail</a></li></ol></li><li class="chapter-item expanded "><a href="../../LakeCTF2022/others.html"><strong aria-hidden="true">2.</strong> other write ups, not by me</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fun type system</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="part-two-the-other-rev"><a class="header" href="#part-two-the-other-rev">Part two: The other rev</a></h3>
<p>We've kind of ignored the L[ae]k[ae] functions up until now, but after the work
we've done in <code>Lake</code>, the previously gibberish sequences of traits have been 
decoded to almost readable sequences of instructions, the assembly of our <code>Lake</code> 
virtual machine.</p>
<p>First, let's put <code>Leka</code>, <code>Leke</code> and <code>Laka</code> one after the other, and
format them so each instruction appears in one line</p>
<pre><code class="language-vim">'&lt;,'&gt;s/\(=&gt;\|=\~:\)/\1\r/g
</code></pre>
<p>We fix any indentation complaints the compiler may give us, and continue with
our analysis.</p>
<p>Now, we start decoding these functions by their appearance in <code>VictoryCondition</code></p>
<pre><code class="language-scala">type VictoryCondition = Lake[
    Leka[FourthToTop],
    Concat[Flag, CharNul =~: EOS],
    Leka[&quot;main&quot;] =~: EOS,
    NewTree[ZeroByte, 8],
    Leka
] =:= (I[20] =~: EOS)
</code></pre>
<p>Therefore, we start with <code>FourthToTop</code></p>
<h4 id="the-first-check"><a class="header" href="#the-first-check">The first check</a></h4>
<p>The instructions returned by <code>FourthToTop</code> are the following</p>
<pre><code class="language-scala">  case FourthToTop =&gt;
    Push[I[42]] =~:
    Call[Pop] =~:
    Push[I[0]] =~:
    Push[I[42]] =~:
    Call[SecondToTop] =~:
    Push[I[8]] =~:
    SubInstr =~:
    JumpIfZero[&quot;stacktrace&quot;] =~:
    Push[I[0]] =~:
    Exit =~:
    EOS
</code></pre>
<p>We can start simulating the state of the stack and see how each instruction 
modifies it</p>
<pre><code class="language-scala">  case FourthToTop =&gt; // f l a g 0
    Push[I[42]] =~:      // 42 f l a g 0
    Call[Pop] =~:        // ?
</code></pre>
<p>We run into a call to <code>Pop</code>, which we don't know how it affects the stack, so 
before proceeding with <code>FourthToTop</code>, we take a look at <code>Pop</code></p>
<pre><code class="language-scala">  case Pop =&gt;             // a b ...
    SecondToTop =~:       // b a ...
    DoubleHead =~:        // b b a ...
    JumpIfZero[CharL] =~: // b a ...
    SecondToTop =~:       // a b ...
    DoubleHead =~:        // a a b ...
    ThirdToTop =~:        // b a a ...
    SecondToTop =~:       // a b a ...
    Store =~:             // a ...     [*a = b]
    Push[I[1]] =~:        // 1 a ...
    AddInstr =~:          // (a+1) ...
    Jump[Pop] =~:         // (a+1) c ..
    EOS
</code></pre>
<p><code>Pop</code> does three things:</p>
<ol>
<li>It keeps a counter in <code>a</code></li>
<li>If <code>b</code> isn't 0, it stores it in memory address a</li>
<li>It increments <code>a</code> and calls <code>Pop</code> again</li>
</ol>
<p>Since <code>b</code> was consumed, for this next call of <code>Pop</code>, <code>b</code> is taken to be the next 
element in the stack. From this we see that <code>Pop</code> performs a scan of the stack,
storing its elements in memory consecutively, starting at address <code>a</code>, until it
finds a <code>0</code> in the stack, after which it jumps to <code>CharL</code>.</p>
<pre><code class="language-scala">  case CharL =&gt;     // 0 a ... // Since b = 0
    SecondToTop =~: // a 0 ...
    Store =~:       // ...     [*a = 0]
    Return =~:
    EOS
</code></pre>
<p>In <code>CharL</code> we simply store the <code>0</code> in memory and return from <code>Pop</code></p>
<p>Therefore, we've seen that <code>Pop</code> loads into memory the contents in the stack, 
starting at the position given by the head of the stack. It functions kind of 
like a <code>loadstr</code> function</p>
<p>Some pseudocode for it would be</p>
<pre><code class="language-scala">def loadstr(a: Byte, stack: List[Byte]) =
    for (b &lt;- stack) do
        Memory(a) = b
        if (b == 0)
            return
        a += 1
</code></pre>
<p>Now we can come back to <code>FourthToTop</code> and continue with our analysis</p>
<pre><code class="language-scala">  case FourthToTop =&gt;     // f l a g 0
    Push[I[42]] =~:       // 42 f l a g 0
    Call[Pop] =~:         //               [loadstr(42, f l a g 0)]
    Push[I[0]] =~:        // 0
    Push[I[42]] =~:       // 42
    Call[SecondToTop] =~: // ?
</code></pre>
<p>Now we perform a second call, this time to <code>SecondToTop</code> which we analyze like
with <code>Pop</code></p>
<pre><code class="language-scala">  case SecondToTop =&gt;                    // a b ...
    DoubleHead =~:                       // a a b ...
    Load =~:                             // *a a b ...
    JumpIfZero[&quot;recurse-trampoline&quot;] =~: // a b ...
    Push[I[1]] =~:                       // 1 a b ...
    AddInstr =~:                         // (a+1) b ...
    SecondToTop =~:                      // b (a+1) ...
    Push[I[1]] =~:                       // 1 b (a+1) ...
    AddInstr =~:                         // (b+1) (a+1) ...
    SecondToTop =~:                      // (a+1) (b+1) ...
    Jump[SecondToTop] =~:                // (a+1) (b+1) ...
    EOS
</code></pre>
<p>From what we can see, <code>SecondToTop</code> scans memory, starting from <code>a</code>, and checks
if it stores a 0. If it doesn't, it moves to the next byte in memory, and
increases the value in <code>b</code> by 1. If the value in memory is 0, it jumps to 
`&quot;recurse-trampoline&quot;</p>
<pre><code class="language-scala">  case &quot;recurse-trampoline&quot; =&gt; // a b ...
    Pop =~:                    // b ...
    Return =~:
    EOS
</code></pre>
<p>This just gets rid of the memory address and returns the counting value we had
in the second position.</p>
<p>Since <code>SecondToTop</code> is called with <code>a=42</code> and <code>b=0</code>, what this ends up doing is
computing the length of the string we just loaded with <code>Pop</code> (<code>loadstr</code>). It 
works like <code>strlen</code> in C</p>
<p>In pseudocode</p>
<pre><code class="language-scala">def strlen(a: Byte, b: Byte) =
    while(Memory(a) != 0)
        a += 1
        b += 1
    return b
</code></pre>
<p>With this, we have enough information to finish decoding <code>FourthToTop</code></p>
<pre><code class="language-scala">  case FourthToTop =&gt;            // f l a g 0
    Push[I[42]] =~:              // 42 f l a g 0
    Call[Pop] =~:                //               [loadstr(42, f l a g 0)]
    Push[I[0]] =~:               // 0
    Push[I[42]] =~:              // 42 0 
    Call[SecondToTop] =~:        // len           [len = strlen(42,0)]
    Push[I[8]] =~:               // 8 len
    SubInstr =~:                 // (len-8)
    JumpIfZero[&quot;stacktrace&quot;] =~: //
    Push[I[0]] =~:               // 0
    Exit =~:
    EOS
</code></pre>
<p>After getting the length of the flag, we check whether the length of the flag is
8. If it isn't, we end execution with a 0 in the stack. Since we've seen that we
need to exit with a 20, exiting with a 0 is a failure, so we now know the length
of the flag must be 8</p>
<h4 id="the-second-check"><a class="header" href="#the-second-check">The second check</a></h4>
<p>If the length of the flag is correct, we jump to <code>&quot;stacktrace&quot;</code></p>
<pre><code class="language-scala">  case &quot;stacktrace&quot; =&gt;
    Push[I[0]] =~:
    Push[I[42]] =~:
    Call[&quot;strlen&quot;] =~:
    Push[I[13]] =~:
    SubInstr =~:
    JumpIfZero[&quot;exception-landing-pad&quot;] =~:
    Push[I[0]] =~:
    Exit =~:
    EOS
</code></pre>
<p>As we did before, we start with the analysis until we reach a call</p>
<pre><code class="language-scala">  case &quot;stacktrace&quot; =&gt; //
    Push[I[0]] =~:     // 0
    Push[I[42]] =~:    // 42 0
    Call[&quot;strlen&quot;] =~: // ?
</code></pre>
<p>And now we have a look at <code>&quot;strleǹ&quot;</code>, not to be confused with <code>Pop</code> which we 
previously saw worked like a <code>strlen</code> function. Totally different</p>
<pre><code class="language-scala">  case &quot;strlen&quot; =&gt;           // a b ...
    DoubleHead =~:           // a a b ...
    Load =~:                 // *a a b ...
    DoubleHead =~:           // *a *a a b ...
    JumpIfZero[SubInstr] =~: // *a a b ...
    ThirdToTop =~:           // b *a a ...
    XorInstr =~:             // (*a^b) a ...
    SecondToTop =~:          // a (*a^b)
    Push[I[1]] =~:           // 1 a (*a^b) 
    AddInstr =~:             // (a+1) (*a^b)
    Jump[&quot;strlen&quot;] =~:       // (a+1) (*a^b)
    EOS
</code></pre>
<p>This function iterates over the values in memory, starting from <code>a</code>, and if
they are not 0, XORs them with <code>b</code> and continues to the next value in memory.
If the value is 0, it jumps to <code>SubInstr</code> </p>
<pre><code class="language-scala">  case SubInstr =&gt; // *a a b ...
    Pop =~:        // a b ...
    Pop =~:        // b ...
    Return =~:
    EOS
</code></pre>
<p>This one leaves only the accumulated XORs of the sequence in the stack and 
returns.</p>
<p>Therefore, we see that <code>&quot;strlen&quot;</code> xors all the elements in memory until it
encounters a 0, at which point it returns. It works like a <code>xorstr</code> function</p>
<pre><code class="language-scala">def xorstr(a: Byte, b: Byte) =
    while(Memory(a) != 0)
        b = b ^ Memory(a)
        a += 1
    return b
</code></pre>
<p>Therefore, continuing the analysis of <code>SecondToTop</code>, we can finish the analysis</p>
<pre><code class="language-scala">  case &quot;stacktrace&quot; =&gt;                      //
    Push[I[0]] =~:                          // 0
    Push[I[42]] =~:                         // 42 0
    Call[&quot;strlen&quot;] =~:                      // xor     [xor = xorstr(42,0)]
    Push[I[13]] =~:                         // 13 xor
    SubInstr =~:                            // (xor-13)
    JumpIfZero[&quot;exception-landing-pad&quot;] =~: // 
    Push[I[0]] =~:                          // 0
    Exit =~:
    EOS
</code></pre>
<p>Afterwards we check if the xor of the flag is 13. If it isn't we fail as we did
before, which means gives us our second piece of information about the flag.</p>
<p>If the xor of the flag is indeed 13, we continue to <code>&quot;exception-landing-pad&quot;</code></p>
<h4 id="the-third-check"><a class="header" href="#the-third-check">The third check</a></h4>
<p>In <code>&quot;exception-landing-pad&quot;</code> we encounter the following code</p>
<pre><code class="language-scala">  case &quot;exception-landing-pad&quot; =&gt;
    Push[I[8]] =~:
    Push[I[42]] =~:
    Call[ThirdToTop] =~:
    Push[I[69]] =~:
    Push[I[42]] =~:
    Push[I[7]] =~:
    Call[&quot;main&quot;] =~:
    Push[I[0]] =~:
    Push[I[40]] =~:
    Push[I[32]] =~:
    Push[I[24]] =~:
    Push[I[29]] =~:
    Push[I[48]] =~:
    Push[I[65]] =~:
    Push[I[49]] =~:
    Push[I[40]] =~:
    Push[I[111]] =~:
    Call[Pop] =~:
    Push[I[69]] =~:
    Push[I[111]] =~:
    Push[I[7]] =~:
    Call[Load] =~:
    Push[I[1]] =~:
    SubInstr =~:
    JumpIfZero[OffBit] =~:
    Push[I[0]] =~:
    Exit =~:
    EOS
</code></pre>
<p>This one is longer than the others, but it doesn't take long to find a call to
another function we have to stop to analyze</p>
<pre><code class="language-scala">  case &quot;exception-landing-pad&quot; =&gt; // 
    Push[I[8]] =~:                // 8
    Push[I[42]] =~:               // 42 8
    Call[ThirdToTop] =~:          // ?
</code></pre>
<p>In the instructions for <code>ThirdToTop</code> we find the following</p>
<pre><code class="language-scala">  case ThirdToTop =&gt; // a b ...
    DoubleHead =~:   // a a b ...
    ThirdToTop =~:   // b a a ...
    AddInstr =~:     // (a+b) a ...
    SecondToTop =~:  // a (a+b) ...
    Load =~:         // *a (a+b) ...
    SecondToTop =~:  // (a+b) *a ...
    Store =~:        // ...      [a[b] = *a]
    Return =~:
    EOS
</code></pre>
<p>Which basically just copies whatever value was in memory at <code>a</code> to the 
address <code>a+b</code> and returns nothing. Since in our case, it's being called
with 42 and 8 as <code>a</code> and <code>b</code>, it's replacing the 0 delimiter in memory
with the first letter of the flag</p>
<pre><code class="language-scala">  case &quot;exception-landing-pad&quot; =&gt; // 
    Push[I[8]] =~:                // 8
    Push[I[42]] =~:               // 42 8
    Call[ThirdToTop] =~:          //        [*50 = *42]
    Push[I[69]] =~:               // 69
    Push[I[42]] =~:               // 42 69
    Push[I[7]] =~:                // 7 42 69
    Call[&quot;main&quot;] =~:              // ?
</code></pre>
<p>Now we perform a call to <code>&quot;main&quot;</code>, which is another big function</p>
<pre><code class="language-scala">  case &quot;main&quot; =&gt;
    DoubleHead =~:
    JumpIfZero[CharE] =~:
    ThirdToTop =~:
    DoubleHead =~:
    FourthToTop =~:
    DoubleHead =~:
    ThirdToTop =~:
    SecondToTop =~:
    Call[CharF] =~:
    Push[I[1]] =~:
    AddInstr =~:
    SecondToTop =~:
    Push[I[1]] =~:
    AddInstr =~:
    ThirdToTop =~:
    Push[I[1]] =~:
    SubInstr =~:
    ThirdToTop =~:
    SecondToTop =~:
    Jump[&quot;main&quot;] =~:
    EOS
</code></pre>
<p>We analyze <code>&quot;main&quot;</code> until we find a call to <code>CharF</code></p>
<pre><code class="language-scala">  case &quot;main&quot; =&gt;          // a b c ...
    DoubleHead =~:        // a a b c ...
    JumpIfZero[CharE] =~: // a b c ...
    ThirdToTop =~:        // c a b ...
    DoubleHead =~:        // c c a b ...
    FourthToTop =~:       // b c c a ...
    DoubleHead =~:        // b b c c a ...
    ThirdToTop =~:        // c b b c a ...
    SecondToTop =~:       // b c b c a ...
    Call[CharF] =~:       // ?
</code></pre>
<p>In <code>CharF</code>, we proceed to analyze as we've done so far</p>
<pre><code class="language-scala">  case CharF =&gt;     // a b ...
    DoubleHead =~:  // a a b ...
    Push[I[1]] =~:  // 1 a a b ...
    AddInstr =~:    // (a+1) a b ...
    DoubleHead =~:  // (a+1) (a+1) a b ...
    Push[I[1]] =~:  // 1 (a+1) (a+1) a b ...
    AddInstr =~:    // (a+2) (a+1) a b ...
    Load =~:        // *(a+2) (a+1) a b ...
    SecondToTop =~: // (a+1) *(a+2) a b ...
    Load =~:        // *(a+1) *(a+2) a b ...
    ThirdToTop =~:  // a *(a+1) *(a+2) b ...
    Load =~:        // *a *(a+1) *(a+2) b ...
    AddInstr =~:    // (*a+*(a+1)) *(a+2) b ...
    AddInstr =~:    // (*a+*(a+1)+*(a+2)) b ...
    SecondToTop =~: // b *a+*(a+1)+*(a+2) ...
    Store =~:       // ...                     [*b = a[0] + a[1] + a[2]]
    Return =~:
    EOS
</code></pre>
<p>We see that the whole purpose of this operation is to compute the sum of
the three successive values in memory starting at <code>a</code>, and we store them
at position <code>b</code>.</p>
<pre><code class="language-scala">  case &quot;main&quot; =&gt;          // a b c ...
    DoubleHead =~:        // a a b c ...
    JumpIfZero[CharE] =~: // a b c ...
    ThirdToTop =~:        // c a b ...
    DoubleHead =~:        // c c a b ...
    FourthToTop =~:       // b c c a ...
    DoubleHead =~:        // b b c c a ...
    ThirdToTop =~:        // c b b c a ...
    SecondToTop =~:       // b c b c a ...
    Call[CharF] =~:       // b c a ...             [*c = b[0] + b[1] + b[2]]
    Push[I[1]] =~:        // 1 b c a ...
    AddInstr =~:          // (b+1) c a ...
    SecondToTop =~:       // c (b+1) a ...
    Push[I[1]] =~:        // 1 c (b+1) a ...
    AddInstr =~:          // (c+1) (b+1) a ...
    ThirdToTop =~:        // a (c+1) (b+1) ...
    Push[I[1]] =~:        // 1 a (c+1) (b+1) ...
    SubInstr =~:          // (a-1) (c+1) (b+1) ...
    ThirdToTop =~:        // (b+1) (a-1) (c+1) ... 
    SecondToTop =~:       // (a-1) (b+1) (c+1) ... 
    Jump[&quot;main&quot;] =~:      // (a-1) (b+1) (c+1) ...
    EOS
</code></pre>
<p>We see that <code>&quot;main&quot;</code> stores the sums of the sub-sequence of 3 elements
starting at <code>b</code> in <code>c</code>, and moves on to the next element. The iteration stops when the
counter in <code>a</code> reaches 0, at which point we jump to <code>CharE</code></p>
<pre><code class="language-scala">  case CharE =&gt; // a b c ...
    Pop =~:     // b c ...
    Pop =~:     // c ...
    Pop =~:     // ...
    Return =~:
    EOS
</code></pre>
<p>Which just gets rid of the values of <code>a</code>, <code>b</code> and <code>c</code> and returns from <code>&quot;main&quot;</code>.</p>
<p>In short, <code>&quot;main&quot;</code> stores in <code>c</code> the sums of the first <code>a</code> sums of subsequences
of length 3 in <code>b</code>. In pseudocode, this would be</p>
<pre><code class="language-scala">def sumOfThree(b: Byte, c: Byte) =
    Memory(c) = Memory(b) + Memory(b+1) + Memory(b+2)
def sumsOfThree(a: Byte, b: Byte, c: Byte) =
    while(a != 0)
        sumOfThree(b,c)
        b+=1
        c+=1
        a-=1
</code></pre>
<p>Here <code>CharF</code> corresponds to <code>sumOfThree(b,c)</code> and <code>&quot;main&quot;</code> to <code>sumsOfThree(a,b,c)</code></p>
<pre><code class="language-scala">  case &quot;exception-landing-pad&quot; =&gt; // 
    Push[I[8]] =~:       // 8
    Push[I[42]] =~:      // 42 8
    Call[ThirdToTop] =~: //                      [*50 = *42]
    Push[I[69]] =~:      // 69
    Push[I[42]] =~:      // 42 69
    Push[I[7]] =~:       // 7 42 69
    Call[&quot;main&quot;] =~:     //                      [sumsOfThree(7,42,69)]
    Push[I[0]] =~:       // 0
    Push[I[40]] =~:      // 40 0
    Push[I[32]] =~:      // 32 40 0
    Push[I[24]] =~:      // 24 32 40 0
    Push[I[29]] =~:      // 29 24 32 40 0
    Push[I[48]] =~:      // 48 29 24 32 40 0
    Push[I[65]] =~:      // 65 48 29 24 32 40 0
    Push[I[49]] =~:      // 49 65 48 29 24 32 40 0
    Push[I[40]] =~:      // 40 49 65 48 29 24 32 40 0
    Push[I[111]] =~:     // 111 49 65 48 29 24 32 40 0
    Call[Pop] =~:        //                      [loadstr(111, 49 65 ... 40 0)]
    Push[I[69]] =~:      // 69
    Push[I[111]] =~:     // 111 69
    Push[I[7]] =~:       // 7 111 69
    Call[Load] =~:       // ?
</code></pre>
<p>We encounter a call to <code>Pop</code> again, which we've already seen loads the contents
of the stack into memory until a 0 is found, at which point it's stored and the
subroutine stops</p>
<p>After loading the sequence <code>49 65 48 29 24 32 40 0</code> at position <code>111</code>, it calls
<code>Load</code> with the <code>7</code>, <code>111</code> and <code>69</code> in the stack</p>
<pre><code class="language-scala">  case Load =&gt;            // a b c ...
    DoubleHead =~:        // a a b c ...
    JumpIfZero[EOS] =~:   // a b c ...
    ThirdToTop =~:        // c a b ... 
    DoubleHead =~:        // c c a b ...
    Load =~:              // *c c a b ...
    FourthToTop =~:       // b *c c a ...
    DoubleHead =~:        // b b *c c a ...
    Load =~:              // *b b *c c a ...
    ThirdToTop =~:        // *c *b b c a ...
    SubInstr =~:          // (*c-*b) b c a ...
    JumpIfZero[CharP] =~: // b c a ...
    Pop =~:               // c a ...
    Pop =~:               // a ...
    Pop =~:               // ...
    Push[I[0]] =~:        // 0
    Return =~:
    EOS
</code></pre>
<p><code>Load</code> first checks if <code>a</code> is 0, and if it isn't, checks whether the bytes at
positions <code>b</code> and <code>c</code> have the same value in memory. If they aren't the same, 
the function returns a 0.</p>
<p>If <code>a</code> is 0, then we jump to <code>EOS</code>, where we return from <code>Load</code> with a 1 instead</p>
<pre><code class="language-scala">  case EOS =&gt;      // a b c ...
    Pop =~:        // b c ...
    Pop =~:        // c ...
    Pop =~:        // ...
    Push[I[1]] =~: // 1
    Return =~:
    EOS
</code></pre>
<p>If the bytes in <code>c</code> and <code>b</code> hold the same value in memory, then we jump to 
<code>CharP</code></p>
<pre><code class="language-scala">  case CharP =&gt;     // b c a
    Push[I[1]] =~:  // 1 b c a
    AddInstr =~:    // (b+1) c a
    SecondToTop =~: // c (b+1) a
    Push[I[1]] =~:  // 1 c (b+1) a 
    AddInstr =~:    // (c+1) (b+1) a 
    ThirdToTop =~:  // a (c+1) (b+1)
    Push[I[1]] =~:  // 1 a (c+1) (b+1)
    SubInstr =~:    // (a-1) (c+1) (b+1)
    Jump[Load] =~:  // (a-1) (c+1) (b+1)
    EOS
</code></pre>
<p>In <code>CharP</code> we increment <code>b</code> and <code>c</code> by one and decrement the counting value <code>a</code>
by 1.</p>
<p>It's easy to see now that <code>Load</code> is performing a string comparison, although it
switches around the address variables over each iteration, but this has no 
effect in the comparison. A pseudocode version of <code>Load</code> would be a function 
<code>strncmp</code> like the following</p>
<pre><code class="language-scala">def strncmp(a: Byte, b: Byte, c: Byte) =
    while(a != 0)
        if (Memory(a) != Memory(b))
            return 0
        b += 1
        c += 1
        swap(a,b) // This has no effect over the output
        a -= 1
    return 1
</code></pre>
<p>Thanks to this, we can finally completely analyze the behaviour of 
<code>&quot;exception-landing-pad&quot;</code></p>
<pre><code class="language-scala">  case &quot;exception-landing-pad&quot; =&gt; // 
    Push[I[8]] =~:         // 8
    Push[I[42]] =~:        // 42 8
    Call[ThirdToTop] =~:   //                     [*50 = *42]
    Push[I[69]] =~:        // 69
    Push[I[42]] =~:        // 42 69
    Push[I[7]] =~:         // 7 42 69
    Call[&quot;main&quot;] =~:       //                     [sumsOfThree(7,42,69)]
    Push[I[0]] =~:         // 0
    Push[I[40]] =~:        // 40 0
    Push[I[32]] =~:        // 32 40 0
    Push[I[24]] =~:        // 24 32 40 0
    Push[I[29]] =~:        // 29 24 32 40 0
    Push[I[48]] =~:        // 48 29 24 32 40 0
    Push[I[65]] =~:        // 65 48 29 24 32 40 0
    Push[I[49]] =~:        // 49 65 48 29 24 32 40 0
    Push[I[40]] =~:        // 40 49 65 48 29 24 32 40 0
    Push[I[111]] =~:       // 111 49 65 48 29 24 32 40 0
    Call[Pop] =~:          //                     [loadstr(111, 49 65 ... 40 0)]
    Push[I[69]] =~:        // 69
    Push[I[111]] =~:       // 111 69
    Push[I[7]] =~:         // 7 111 69
    Call[Load] =~:         // res                 [res = strncmp(7,111,69)]
    Push[I[1]] =~:         // 1 res
    SubInstr =~:           // (res-1)
    JumpIfZero[OffBit] =~: //
    Push[I[0]] =~:         // 0
    Exit =~:
    EOS
</code></pre>
<p>And so, what <code>&quot;exception-landing-pad&quot;</code> does is check if the flag's sums of three
consecutive elements are <code>49 65 48 29 24 32 40</code>. If this is true, then we jump
to <code>OffBit</code></p>
<pre><code class="language-scala">  case OffBit =&gt;    // 
    Push[I[20]] =~: // 20
    Exit =~:
    EOS
</code></pre>
<p>Which ends the evaluation, returning a 20 and successfully compiling the program.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../LakeCTF2022/fun-type-system/part-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../LakeCTF2022/fun-type-system/part-3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../LakeCTF2022/fun-type-system/part-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../LakeCTF2022/fun-type-system/part-3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
